\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}

% Configuração de margens
\geometry{top=3cm, bottom=2cm, left=3cm, right=2cm}

% Configuração de código Java
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{\textbf{Relatório de Implementação: Compilador da Linguagem CF}}
\author{Disciplina de Compiladores \\ PUC Minas}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este documento descreve o desenvolvimento de um compilador para a linguagem CF (CompilaFofo), focando na implementação prática da análise léxica e na fundamentação teórica das fases subsequentes. O projeto, desenvolvido em Java, utiliza autômatos finitos determinísticos (DFA) controlados por uma matriz de transição CSV para o reconhecimento de tokens.
\end{abstract}

\tableofcontents
\newpage

\section{Introdução}
A construção de um compilador envolve diversas etapas complexas que transformam o código-fonte escrito em uma linguagem de alto nível em código de máquina ou executável. Este projeto visa implementar as fases iniciais de análise para a linguagem CF, estabelecendo a base para um processo de compilação completo.

\section{Fases da Compilação}
O processo de análise do código-fonte (front-end) é tradicionalmente dividido em três fases principais, cada uma com responsabilidades distintas e sequenciais.

\subsection{Análise Léxica (Scanner)}
É a primeira fase do compilador. Sua função principal é ler o fluxo de caracteres do código-fonte e agrupá-los em sequências significativas chamadas \textbf{lexemas}. Para cada lexema identificado que corresponde a um padrão da linguagem, o analisador léxico produz um \textbf{token}.
\\
\\
Nesta fase, são removidos espaços em branco, comentários e caracteres de formatação. É também responsabilidade do analisador léxico relatar erros de caracteres inválidos que não pertencem ao alfabeto da linguagem. Esta é a fase atualmente implementada neste projeto.

\subsection{Análise Sintática (Parser)}
A análise sintática recebe a sequência de tokens gerada pelo analisador léxico e verifica se ela obedece às regras gramaticais da linguagem (Gramática Livre de Contexto). O objetivo é criar uma representação hierárquica intermediária, geralmente na forma de uma \textbf{Árvore Sintática Abstrata (AST)}.
\\
\\
Se a análise léxica se preocupa com a formação das palavras, a análise sintática se preocupa com a formação das frases e estruturas (como o aninhamento de blocos \texttt{Se/Senao} ou a estrutura de expressões matemáticas). Erros de sintaxe, como parênteses não balanceados ou falta de ponto-e-vírgula, são detectados aqui.

\subsection{Análise Semântica}
Esta fase utiliza a árvore sintática e a tabela de símbolos para verificar a consistência lógica do programa. O analisador semântico garante que as regras da linguagem que não podem ser capturadas pela gramática livre de contexto sejam respeitadas.
\\
\\
As principais tarefas incluem:
\begin{itemize}
    \item \textbf{Verificação de Tipos (Type Checking):} Garantir que operações sejam realizadas entre tipos compatíveis (ex: não somar um número com uma string).
    \item \textbf{Verificação de Escopo:} Garantir que variáveis sejam declaradas antes de serem usadas e que estejam visíveis no escopo atual.
    \item \textbf{Verificação de Fluxo:} Checar retornos de funções e unicidade de rótulos.
\end{itemize}

\section{Arquitetura do Projeto Implementado}
O projeto Java está organizado para suportar a evolução dessas fases:

\begin{itemize}
    \item \textbf{src/lexicalFinal/}: Contém a lógica do Analisador Léxico (\texttt{AnalyzerFinal.java}).
    \item \textbf{src/symbolTable/}: Gerencia a Tabela de Símbolos, essencial para conectar as fases léxica, sintática e semântica.
    \item \textbf{TransactionTable/}: Contém a definição do autômato (\texttt{TransactionFinal.csv}).
    \item \textbf{Inputs/}: Diretório com códigos fonte de teste (.cf).
\end{itemize}

\section{Implementação da Análise Léxica (Detalhes)}

A implementação atual foca na classe \texttt{AnalyzerFinal.java}, que opera como um autômato finito tabular.

\subsection{Matriz de Transição}
O autômato é definido externamente no arquivo \texttt{TransactionFinal.csv}, permitindo flexibilidade. Atualmente, o autômato possui \textbf{77 estados}, capazes de reconhecer:
\begin{itemize}
    \item Palavras reservadas (\texttt{COMMAND}) e Tipos (\texttt{TYPE}).
    \item Identificadores (\texttt{IDENTIFY}) e Constantes Booleanas.
    \item Literais Numéricos (\texttt{NUMERO}) e de Texto (\texttt{STRING}).
    \item Operadores Aritméticos, Relacionais e Lógicos (incluindo compostos como \texttt{**} e \texttt{>=}).
\end{itemize}

\subsection{Processo de Reconhecimento}
O código percorre o input caractere por caractere, transitando entre estados. Ao atingir um estado final, um token é gerado e armazenado. O analisador trata ambiguidades usando \textit{lookahead} (olhar um caractere à frente), essencial para distinguir, por exemplo, o operador de atribuição (\texttt{=}) do operador de igualdade (\texttt{==}).

\section{Conclusão}
A fase de análise léxica está completa e funcional, servindo como fundação sólida para o compilador da linguagem CF. O próximo passo no desenvolvimento será a implementação do Analisador Sintático, que consumirá os tokens gerados por esta etapa para validar a estrutura gramatical dos programas.

\end{document}
